// This code was autogenerated with `dbus-codegen-rust -d org.freedesktop.portal.Desktop -p /org/freedesktop/portal/desktop`, see https://github.com/diwic/dbus-rs
use dbus as dbus;
#[allow(unused_imports)]
#[allow(dead_code)]
#[allow(unused)]
use dbus::arg;
use dbus::blocking;

pub trait OrgFreedesktopDBusProperties {
    fn get(&self, interface_name: &str, property_name: &str) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::Error>;
    fn get_all(&self, interface_name: &str) -> Result<arg::PropMap, dbus::Error>;
    fn set(&self, interface_name: &str, property_name: &str, value: arg::Variant<Box<dyn arg::RefArg>>) -> Result<(), dbus::Error>;
}

#[derive(Debug)]
pub struct OrgFreedesktopDBusPropertiesPropertiesChanged {
    pub interface_name: String,
    pub changed_properties: arg::PropMap,
    pub invalidated_properties: Vec<String>,
}

impl arg::AppendAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.interface_name, i);
        arg::RefArg::append(&self.changed_properties, i);
        arg::RefArg::append(&self.invalidated_properties, i);
    }
}

impl arg::ReadAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopDBusPropertiesPropertiesChanged {
            interface_name: i.read()?,
            changed_properties: i.read()?,
            invalidated_properties: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopDBusPropertiesPropertiesChanged {
    const NAME: &'static str = "PropertiesChanged";
    const INTERFACE: &'static str = "org.freedesktop.DBus.Properties";
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopDBusProperties for blocking::Proxy<'a, C> {

    fn get(&self, interface_name: &str, property_name: &str) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::Error> {
        self.method_call("org.freedesktop.DBus.Properties", "Get", (interface_name, property_name, ))
            .and_then(|r: (arg::Variant<Box<dyn arg::RefArg + 'static>>, )| Ok(r.0, ))
    }

    fn get_all(&self, interface_name: &str) -> Result<arg::PropMap, dbus::Error> {
        self.method_call("org.freedesktop.DBus.Properties", "GetAll", (interface_name, ))
            .and_then(|r: (arg::PropMap, )| Ok(r.0, ))
    }

    fn set(&self, interface_name: &str, property_name: &str, value: arg::Variant<Box<dyn arg::RefArg>>) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.DBus.Properties", "Set", (interface_name, property_name, value, ))
    }
}

pub trait OrgFreedesktopDBusIntrospectable {
    fn introspect(&self) -> Result<String, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopDBusIntrospectable for blocking::Proxy<'a, C> {

    fn introspect(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.DBus.Introspectable", "Introspect", ())
            .and_then(|r: (String, )| Ok(r.0, ))
    }
}

pub trait OrgFreedesktopDBusPeer {
    fn ping(&self) -> Result<(), dbus::Error>;
    fn get_machine_id(&self) -> Result<String, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopDBusPeer for blocking::Proxy<'a, C> {

    fn ping(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.DBus.Peer", "Ping", ())
    }

    fn get_machine_id(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.DBus.Peer", "GetMachineId", ())
            .and_then(|r: (String, )| Ok(r.0, ))
    }
}

pub trait OrgFreedesktopPortalInhibit {
    fn inhibit(&self, window: &str, flags: u32, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn create_monitor(&self, window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn query_end_response(&self, session_handle: dbus::Path) -> Result<(), dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

#[derive(Debug)]
pub struct OrgFreedesktopPortalInhibitStateChanged {
    pub session_handle: dbus::Path<'static>,
    pub state: arg::PropMap,
}

impl arg::AppendAll for OrgFreedesktopPortalInhibitStateChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.session_handle, i);
        arg::RefArg::append(&self.state, i);
    }
}

impl arg::ReadAll for OrgFreedesktopPortalInhibitStateChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopPortalInhibitStateChanged {
            session_handle: i.read()?,
            state: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopPortalInhibitStateChanged {
    const NAME: &'static str = "StateChanged";
    const INTERFACE: &'static str = "org.freedesktop.portal.Inhibit";
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalInhibit for blocking::Proxy<'a, C> {

    fn inhibit(&self, window: &str, flags: u32, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.Inhibit", "Inhibit", (window, flags, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn create_monitor(&self, window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.Inhibit", "CreateMonitor", (window, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn query_end_response(&self, session_handle: dbus::Path) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.Inhibit", "QueryEndResponse", (session_handle, ))
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.Inhibit", "version")
    }
}

pub trait OrgFreedesktopPortalBackground {
    fn request_background(&self, parent_window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn set_status(&self, options: arg::PropMap) -> Result<(), dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalBackground for blocking::Proxy<'a, C> {

    fn request_background(&self, parent_window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.Background", "RequestBackground", (parent_window, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn set_status(&self, options: arg::PropMap) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.Background", "SetStatus", (options, ))
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.Background", "version")
    }
}

pub trait OrgFreedesktopPortalLocation {
    fn create_session(&self, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn start(&self, session_handle: dbus::Path, parent_window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

#[derive(Debug)]
pub struct OrgFreedesktopPortalLocationLocationUpdated {
    pub session_handle: dbus::Path<'static>,
    pub location: arg::PropMap,
}

impl arg::AppendAll for OrgFreedesktopPortalLocationLocationUpdated {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.session_handle, i);
        arg::RefArg::append(&self.location, i);
    }
}

impl arg::ReadAll for OrgFreedesktopPortalLocationLocationUpdated {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopPortalLocationLocationUpdated {
            session_handle: i.read()?,
            location: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopPortalLocationLocationUpdated {
    const NAME: &'static str = "LocationUpdated";
    const INTERFACE: &'static str = "org.freedesktop.portal.Location";
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalLocation for blocking::Proxy<'a, C> {

    fn create_session(&self, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.Location", "CreateSession", (options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn start(&self, session_handle: dbus::Path, parent_window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.Location", "Start", (session_handle, parent_window, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.Location", "version")
    }
}

pub trait OrgFreedesktopPortalNotification {
    fn add_notification(&self, id: &str, notification: arg::PropMap) -> Result<(), dbus::Error>;
    fn remove_notification(&self, id: &str) -> Result<(), dbus::Error>;
    fn supported_options(&self) -> Result<arg::PropMap, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

#[derive(Debug)]
pub struct OrgFreedesktopPortalNotificationActionInvoked {
    pub id: String,
    pub action: String,
    pub parameter: Vec<arg::Variant<Box<dyn arg::RefArg + 'static>>>,
}

impl arg::AppendAll for OrgFreedesktopPortalNotificationActionInvoked {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.id, i);
        arg::RefArg::append(&self.action, i);
        arg::RefArg::append(&self.parameter, i);
    }
}

impl arg::ReadAll for OrgFreedesktopPortalNotificationActionInvoked {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopPortalNotificationActionInvoked {
            id: i.read()?,
            action: i.read()?,
            parameter: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopPortalNotificationActionInvoked {
    const NAME: &'static str = "ActionInvoked";
    const INTERFACE: &'static str = "org.freedesktop.portal.Notification";
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalNotification for blocking::Proxy<'a, C> {

    fn add_notification(&self, id: &str, notification: arg::PropMap) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.Notification", "AddNotification", (id, notification, ))
    }

    fn remove_notification(&self, id: &str) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.Notification", "RemoveNotification", (id, ))
    }

    fn supported_options(&self) -> Result<arg::PropMap, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.Notification", "SupportedOptions")
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.Notification", "version")
    }
}

pub trait OrgFreedesktopPortalScreenshot {
    fn screenshot(&self, parent_window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn pick_color(&self, parent_window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalScreenshot for blocking::Proxy<'a, C> {

    fn screenshot(&self, parent_window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.Screenshot", "Screenshot", (parent_window, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn pick_color(&self, parent_window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.Screenshot", "PickColor", (parent_window, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.Screenshot", "version")
    }
}

pub trait OrgFreedesktopPortalUsb {
    fn create_session(&self, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn enumerate_devices(&self, options: arg::PropMap) -> Result<Vec<(String, arg::PropMap,)>, dbus::Error>;
    fn acquire_devices(&self, parent_window: &str, devices: Vec<(&str, arg::PropMap,)>, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn finish_acquire_devices(&self, handle: dbus::Path, options: arg::PropMap) -> Result<(Vec<(String, arg::PropMap,)>, bool), dbus::Error>;
    fn release_devices(&self, devices: Vec<&str>, options: arg::PropMap) -> Result<(), dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

#[derive(Debug)]
pub struct OrgFreedesktopPortalUsbDeviceEvents {
    pub session_handle: dbus::Path<'static>,
    pub events: Vec<(String, String, arg::PropMap,)>,
}

impl arg::AppendAll for OrgFreedesktopPortalUsbDeviceEvents {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.session_handle, i);
        arg::RefArg::append(&self.events, i);
    }
}

impl arg::ReadAll for OrgFreedesktopPortalUsbDeviceEvents {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopPortalUsbDeviceEvents {
            session_handle: i.read()?,
            events: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopPortalUsbDeviceEvents {
    const NAME: &'static str = "DeviceEvents";
    const INTERFACE: &'static str = "org.freedesktop.portal.Usb";
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalUsb for blocking::Proxy<'a, C> {

    fn create_session(&self, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.Usb", "CreateSession", (options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn enumerate_devices(&self, options: arg::PropMap) -> Result<Vec<(String, arg::PropMap,)>, dbus::Error> {
        self.method_call("org.freedesktop.portal.Usb", "EnumerateDevices", (options, ))
            .and_then(|r: (Vec<(String, arg::PropMap,)>, )| Ok(r.0, ))
    }

    fn acquire_devices(&self, parent_window: &str, devices: Vec<(&str, arg::PropMap,)>, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.Usb", "AcquireDevices", (parent_window, devices, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn finish_acquire_devices(&self, handle: dbus::Path, options: arg::PropMap) -> Result<(Vec<(String, arg::PropMap,)>, bool), dbus::Error> {
        self.method_call("org.freedesktop.portal.Usb", "FinishAcquireDevices", (handle, options, ))
    }

    fn release_devices(&self, devices: Vec<&str>, options: arg::PropMap) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.Usb", "ReleaseDevices", (devices, options, ))
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.Usb", "version")
    }
}

pub trait OrgFreedesktopPortalAccount {
    fn get_user_information(&self, window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalAccount for blocking::Proxy<'a, C> {

    fn get_user_information(&self, window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.Account", "GetUserInformation", (window, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.Account", "version")
    }
}

pub trait OrgFreedesktopPortalNetworkMonitor {
    fn get_available(&self) -> Result<bool, dbus::Error>;
    fn get_metered(&self) -> Result<bool, dbus::Error>;
    fn get_connectivity(&self) -> Result<u32, dbus::Error>;
    fn get_status(&self) -> Result<arg::PropMap, dbus::Error>;
    fn can_reach(&self, hostname: &str, port: u32) -> Result<bool, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

#[derive(Debug)]
pub struct OrgFreedesktopPortalNetworkMonitorChanged {
}

impl arg::AppendAll for OrgFreedesktopPortalNetworkMonitorChanged {
    fn append(&self, _: &mut arg::IterAppend) {
    }
}

impl arg::ReadAll for OrgFreedesktopPortalNetworkMonitorChanged {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopPortalNetworkMonitorChanged {
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopPortalNetworkMonitorChanged {
    const NAME: &'static str = "changed";
    const INTERFACE: &'static str = "org.freedesktop.portal.NetworkMonitor";
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalNetworkMonitor for blocking::Proxy<'a, C> {

    fn get_available(&self) -> Result<bool, dbus::Error> {
        self.method_call("org.freedesktop.portal.NetworkMonitor", "GetAvailable", ())
            .and_then(|r: (bool, )| Ok(r.0, ))
    }

    fn get_metered(&self) -> Result<bool, dbus::Error> {
        self.method_call("org.freedesktop.portal.NetworkMonitor", "GetMetered", ())
            .and_then(|r: (bool, )| Ok(r.0, ))
    }

    fn get_connectivity(&self) -> Result<u32, dbus::Error> {
        self.method_call("org.freedesktop.portal.NetworkMonitor", "GetConnectivity", ())
            .and_then(|r: (u32, )| Ok(r.0, ))
    }

    fn get_status(&self) -> Result<arg::PropMap, dbus::Error> {
        self.method_call("org.freedesktop.portal.NetworkMonitor", "GetStatus", ())
            .and_then(|r: (arg::PropMap, )| Ok(r.0, ))
    }

    fn can_reach(&self, hostname: &str, port: u32) -> Result<bool, dbus::Error> {
        self.method_call("org.freedesktop.portal.NetworkMonitor", "CanReach", (hostname, port, ))
            .and_then(|r: (bool, )| Ok(r.0, ))
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.NetworkMonitor", "version")
    }
}

pub trait OrgFreedesktopPortalPrint {
    fn prepare_print(&self, parent_window: &str, title: &str, settings: arg::PropMap, page_setup: arg::PropMap, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn print(&self, parent_window: &str, title: &str, fd: arg::OwnedFd, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalPrint for blocking::Proxy<'a, C> {

    fn prepare_print(&self, parent_window: &str, title: &str, settings: arg::PropMap, page_setup: arg::PropMap, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.Print", "PreparePrint", (parent_window, title, settings, page_setup, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn print(&self, parent_window: &str, title: &str, fd: arg::OwnedFd, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.Print", "Print", (parent_window, title, fd, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.Print", "version")
    }
}

pub trait OrgFreedesktopPortalSettings {
    fn read_all(&self, namespaces: Vec<&str>) -> Result<::std::collections::HashMap<String, arg::PropMap>, dbus::Error>;
    #[deprecated(note = "true")]
    fn read(&self, namespace: &str, key: &str) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::Error>;
    fn read_one(&self, namespace: &str, key: &str) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

#[derive(Debug)]
pub struct OrgFreedesktopPortalSettingsSettingChanged {
    pub namespace: String,
    pub key: String,
    pub value: arg::Variant<Box<dyn arg::RefArg + 'static>>,
}

impl arg::AppendAll for OrgFreedesktopPortalSettingsSettingChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.namespace, i);
        arg::RefArg::append(&self.key, i);
        arg::RefArg::append(&self.value, i);
    }
}

impl arg::ReadAll for OrgFreedesktopPortalSettingsSettingChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopPortalSettingsSettingChanged {
            namespace: i.read()?,
            key: i.read()?,
            value: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopPortalSettingsSettingChanged {
    const NAME: &'static str = "SettingChanged";
    const INTERFACE: &'static str = "org.freedesktop.portal.Settings";
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalSettings for blocking::Proxy<'a, C> {

    fn read_all(&self, namespaces: Vec<&str>) -> Result<::std::collections::HashMap<String, arg::PropMap>, dbus::Error> {
        self.method_call("org.freedesktop.portal.Settings", "ReadAll", (namespaces, ))
            .and_then(|r: (::std::collections::HashMap<String, arg::PropMap>, )| Ok(r.0, ))
    }

    fn read(&self, namespace: &str, key: &str) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::Error> {
        self.method_call("org.freedesktop.portal.Settings", "Read", (namespace, key, ))
            .and_then(|r: (arg::Variant<Box<dyn arg::RefArg + 'static>>, )| Ok(r.0, ))
    }

    fn read_one(&self, namespace: &str, key: &str) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::Error> {
        self.method_call("org.freedesktop.portal.Settings", "ReadOne", (namespace, key, ))
            .and_then(|r: (arg::Variant<Box<dyn arg::RefArg + 'static>>, )| Ok(r.0, ))
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.Settings", "version")
    }
}

pub trait OrgFreedesktopPortalGameMode {
    fn query_status(&self, pid: i32) -> Result<i32, dbus::Error>;
    fn register_game(&self, pid: i32) -> Result<i32, dbus::Error>;
    fn unregister_game(&self, pid: i32) -> Result<i32, dbus::Error>;
    fn query_status_by_pid(&self, target: i32, requester: i32) -> Result<i32, dbus::Error>;
    fn register_game_by_pid(&self, target: i32, requester: i32) -> Result<i32, dbus::Error>;
    fn unregister_game_by_pid(&self, target: i32, requester: i32) -> Result<i32, dbus::Error>;
    fn query_status_by_pidfd(&self, target: arg::OwnedFd, requester: arg::OwnedFd) -> Result<i32, dbus::Error>;
    fn register_game_by_pidfd(&self, target: arg::OwnedFd, requester: arg::OwnedFd) -> Result<i32, dbus::Error>;
    fn unregister_game_by_pidfd(&self, target: arg::OwnedFd, requester: arg::OwnedFd) -> Result<i32, dbus::Error>;
    fn active(&self) -> Result<bool, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalGameMode for blocking::Proxy<'a, C> {

    fn query_status(&self, pid: i32) -> Result<i32, dbus::Error> {
        self.method_call("org.freedesktop.portal.GameMode", "QueryStatus", (pid, ))
            .and_then(|r: (i32, )| Ok(r.0, ))
    }

    fn register_game(&self, pid: i32) -> Result<i32, dbus::Error> {
        self.method_call("org.freedesktop.portal.GameMode", "RegisterGame", (pid, ))
            .and_then(|r: (i32, )| Ok(r.0, ))
    }

    fn unregister_game(&self, pid: i32) -> Result<i32, dbus::Error> {
        self.method_call("org.freedesktop.portal.GameMode", "UnregisterGame", (pid, ))
            .and_then(|r: (i32, )| Ok(r.0, ))
    }

    fn query_status_by_pid(&self, target: i32, requester: i32) -> Result<i32, dbus::Error> {
        self.method_call("org.freedesktop.portal.GameMode", "QueryStatusByPid", (target, requester, ))
            .and_then(|r: (i32, )| Ok(r.0, ))
    }

    fn register_game_by_pid(&self, target: i32, requester: i32) -> Result<i32, dbus::Error> {
        self.method_call("org.freedesktop.portal.GameMode", "RegisterGameByPid", (target, requester, ))
            .and_then(|r: (i32, )| Ok(r.0, ))
    }

    fn unregister_game_by_pid(&self, target: i32, requester: i32) -> Result<i32, dbus::Error> {
        self.method_call("org.freedesktop.portal.GameMode", "UnregisterGameByPid", (target, requester, ))
            .and_then(|r: (i32, )| Ok(r.0, ))
    }

    fn query_status_by_pidfd(&self, target: arg::OwnedFd, requester: arg::OwnedFd) -> Result<i32, dbus::Error> {
        self.method_call("org.freedesktop.portal.GameMode", "QueryStatusByPIDFd", (target, requester, ))
            .and_then(|r: (i32, )| Ok(r.0, ))
    }

    fn register_game_by_pidfd(&self, target: arg::OwnedFd, requester: arg::OwnedFd) -> Result<i32, dbus::Error> {
        self.method_call("org.freedesktop.portal.GameMode", "RegisterGameByPIDFd", (target, requester, ))
            .and_then(|r: (i32, )| Ok(r.0, ))
    }

    fn unregister_game_by_pidfd(&self, target: arg::OwnedFd, requester: arg::OwnedFd) -> Result<i32, dbus::Error> {
        self.method_call("org.freedesktop.portal.GameMode", "UnregisterGameByPIDFd", (target, requester, ))
            .and_then(|r: (i32, )| Ok(r.0, ))
    }

    fn active(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.GameMode", "Active")
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.GameMode", "version")
    }
}

pub trait OrgFreedesktopPortalRemoteDesktop {
    fn create_session(&self, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn select_devices(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn start(&self, session_handle: dbus::Path, parent_window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn notify_pointer_motion(&self, session_handle: dbus::Path, options: arg::PropMap, dx: f64, dy: f64) -> Result<(), dbus::Error>;
    fn notify_pointer_motion_absolute(&self, session_handle: dbus::Path, options: arg::PropMap, stream: u32, x_: f64, y_: f64) -> Result<(), dbus::Error>;
    fn notify_pointer_button(&self, session_handle: dbus::Path, options: arg::PropMap, button: i32, state: u32) -> Result<(), dbus::Error>;
    fn notify_pointer_axis(&self, session_handle: dbus::Path, options: arg::PropMap, dx: f64, dy: f64) -> Result<(), dbus::Error>;
    fn notify_pointer_axis_discrete(&self, session_handle: dbus::Path, options: arg::PropMap, axis: u32, steps: i32) -> Result<(), dbus::Error>;
    fn notify_keyboard_keycode(&self, session_handle: dbus::Path, options: arg::PropMap, keycode: i32, state: u32) -> Result<(), dbus::Error>;
    fn notify_keyboard_keysym(&self, session_handle: dbus::Path, options: arg::PropMap, keysym: i32, state: u32) -> Result<(), dbus::Error>;
    fn notify_touch_down(&self, session_handle: dbus::Path, options: arg::PropMap, stream: u32, slot: u32, x_: f64, y_: f64) -> Result<(), dbus::Error>;
    fn notify_touch_motion(&self, session_handle: dbus::Path, options: arg::PropMap, stream: u32, slot: u32, x_: f64, y_: f64) -> Result<(), dbus::Error>;
    fn notify_touch_up(&self, session_handle: dbus::Path, options: arg::PropMap, slot: u32) -> Result<(), dbus::Error>;
    fn connect_to_eis(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<arg::OwnedFd, dbus::Error>;
    fn available_device_types(&self) -> Result<u32, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalRemoteDesktop for blocking::Proxy<'a, C> {

    fn create_session(&self, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.RemoteDesktop", "CreateSession", (options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn select_devices(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.RemoteDesktop", "SelectDevices", (session_handle, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn start(&self, session_handle: dbus::Path, parent_window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.RemoteDesktop", "Start", (session_handle, parent_window, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn notify_pointer_motion(&self, session_handle: dbus::Path, options: arg::PropMap, dx: f64, dy: f64) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.RemoteDesktop", "NotifyPointerMotion", (session_handle, options, dx, dy, ))
    }

    fn notify_pointer_motion_absolute(&self, session_handle: dbus::Path, options: arg::PropMap, stream: u32, x_: f64, y_: f64) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.RemoteDesktop", "NotifyPointerMotionAbsolute", (session_handle, options, stream, x_, y_, ))
    }

    fn notify_pointer_button(&self, session_handle: dbus::Path, options: arg::PropMap, button: i32, state: u32) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.RemoteDesktop", "NotifyPointerButton", (session_handle, options, button, state, ))
    }

    fn notify_pointer_axis(&self, session_handle: dbus::Path, options: arg::PropMap, dx: f64, dy: f64) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.RemoteDesktop", "NotifyPointerAxis", (session_handle, options, dx, dy, ))
    }

    fn notify_pointer_axis_discrete(&self, session_handle: dbus::Path, options: arg::PropMap, axis: u32, steps: i32) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.RemoteDesktop", "NotifyPointerAxisDiscrete", (session_handle, options, axis, steps, ))
    }

    fn notify_keyboard_keycode(&self, session_handle: dbus::Path, options: arg::PropMap, keycode: i32, state: u32) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.RemoteDesktop", "NotifyKeyboardKeycode", (session_handle, options, keycode, state, ))
    }

    fn notify_keyboard_keysym(&self, session_handle: dbus::Path, options: arg::PropMap, keysym: i32, state: u32) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.RemoteDesktop", "NotifyKeyboardKeysym", (session_handle, options, keysym, state, ))
    }

    fn notify_touch_down(&self, session_handle: dbus::Path, options: arg::PropMap, stream: u32, slot: u32, x_: f64, y_: f64) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.RemoteDesktop", "NotifyTouchDown", (session_handle, options, stream, slot, x_, y_, ))
    }

    fn notify_touch_motion(&self, session_handle: dbus::Path, options: arg::PropMap, stream: u32, slot: u32, x_: f64, y_: f64) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.RemoteDesktop", "NotifyTouchMotion", (session_handle, options, stream, slot, x_, y_, ))
    }

    fn notify_touch_up(&self, session_handle: dbus::Path, options: arg::PropMap, slot: u32) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.RemoteDesktop", "NotifyTouchUp", (session_handle, options, slot, ))
    }

    fn connect_to_eis(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<arg::OwnedFd, dbus::Error> {
        self.method_call("org.freedesktop.portal.RemoteDesktop", "ConnectToEIS", (session_handle, options, ))
            .and_then(|r: (arg::OwnedFd, )| Ok(r.0, ))
    }

    fn available_device_types(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.RemoteDesktop", "AvailableDeviceTypes")
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.RemoteDesktop", "version")
    }
}

pub trait OrgFreedesktopPortalMemoryMonitor {
    fn version(&self) -> Result<u32, dbus::Error>;
}

#[derive(Debug)]
pub struct OrgFreedesktopPortalMemoryMonitorLowMemoryWarning {
    pub level: u8,
}

impl arg::AppendAll for OrgFreedesktopPortalMemoryMonitorLowMemoryWarning {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.level, i);
    }
}

impl arg::ReadAll for OrgFreedesktopPortalMemoryMonitorLowMemoryWarning {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopPortalMemoryMonitorLowMemoryWarning {
            level: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopPortalMemoryMonitorLowMemoryWarning {
    const NAME: &'static str = "LowMemoryWarning";
    const INTERFACE: &'static str = "org.freedesktop.portal.MemoryMonitor";
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalMemoryMonitor for blocking::Proxy<'a, C> {

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.MemoryMonitor", "version")
    }
}

pub trait OrgFreedesktopPortalOpenURI {
    fn open_uri(&self, parent_window: &str, uri: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn open_file(&self, parent_window: &str, fd: arg::OwnedFd, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn open_directory(&self, parent_window: &str, fd: arg::OwnedFd, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn scheme_supported(&self, scheme: &str, options: arg::PropMap) -> Result<bool, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalOpenURI for blocking::Proxy<'a, C> {

    fn open_uri(&self, parent_window: &str, uri: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.OpenURI", "OpenURI", (parent_window, uri, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn open_file(&self, parent_window: &str, fd: arg::OwnedFd, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.OpenURI", "OpenFile", (parent_window, fd, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn open_directory(&self, parent_window: &str, fd: arg::OwnedFd, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.OpenURI", "OpenDirectory", (parent_window, fd, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn scheme_supported(&self, scheme: &str, options: arg::PropMap) -> Result<bool, dbus::Error> {
        self.method_call("org.freedesktop.portal.OpenURI", "SchemeSupported", (scheme, options, ))
            .and_then(|r: (bool, )| Ok(r.0, ))
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.OpenURI", "version")
    }
}

pub trait OrgFreedesktopPortalRealtime {
    fn make_thread_realtime_with_pid(&self, process: u64, thread: u64, priority: u32) -> Result<(), dbus::Error>;
    fn make_thread_high_priority_with_pid(&self, process: u64, thread: u64, priority: i32) -> Result<(), dbus::Error>;
    fn max_realtime_priority(&self) -> Result<i32, dbus::Error>;
    fn min_nice_level(&self) -> Result<i32, dbus::Error>;
    fn rttime_usec_max(&self) -> Result<i64, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalRealtime for blocking::Proxy<'a, C> {

    fn make_thread_realtime_with_pid(&self, process: u64, thread: u64, priority: u32) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.Realtime", "MakeThreadRealtimeWithPID", (process, thread, priority, ))
    }

    fn make_thread_high_priority_with_pid(&self, process: u64, thread: u64, priority: i32) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.Realtime", "MakeThreadHighPriorityWithPID", (process, thread, priority, ))
    }

    fn max_realtime_priority(&self) -> Result<i32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.Realtime", "MaxRealtimePriority")
    }

    fn min_nice_level(&self) -> Result<i32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.Realtime", "MinNiceLevel")
    }

    fn rttime_usec_max(&self) -> Result<i64, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.Realtime", "RTTimeUSecMax")
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.Realtime", "version")
    }
}

pub trait OrgFreedesktopPortalSecret {
    fn retrieve_secret(&self, fd: arg::OwnedFd, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalSecret for blocking::Proxy<'a, C> {

    fn retrieve_secret(&self, fd: arg::OwnedFd, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.Secret", "RetrieveSecret", (fd, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.Secret", "version")
    }
}

pub trait OrgFreedesktopPortalClipboard {
    fn request_clipboard(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<(), dbus::Error>;
    fn set_selection(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<(), dbus::Error>;
    fn selection_write(&self, session_handle: dbus::Path, serial: u32) -> Result<arg::OwnedFd, dbus::Error>;
    fn selection_write_done(&self, session_handle: dbus::Path, serial: u32, success: bool) -> Result<(), dbus::Error>;
    fn selection_read(&self, session_handle: dbus::Path, mime_type: &str) -> Result<arg::OwnedFd, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

#[derive(Debug)]
pub struct OrgFreedesktopPortalClipboardSelectionOwnerChanged {
    pub session_handle: dbus::Path<'static>,
    pub options: arg::PropMap,
}

impl arg::AppendAll for OrgFreedesktopPortalClipboardSelectionOwnerChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.session_handle, i);
        arg::RefArg::append(&self.options, i);
    }
}

impl arg::ReadAll for OrgFreedesktopPortalClipboardSelectionOwnerChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopPortalClipboardSelectionOwnerChanged {
            session_handle: i.read()?,
            options: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopPortalClipboardSelectionOwnerChanged {
    const NAME: &'static str = "SelectionOwnerChanged";
    const INTERFACE: &'static str = "org.freedesktop.portal.Clipboard";
}

#[derive(Debug)]
pub struct OrgFreedesktopPortalClipboardSelectionTransfer {
    pub session_handle: dbus::Path<'static>,
    pub mime_type: String,
    pub serial: u32,
}

impl arg::AppendAll for OrgFreedesktopPortalClipboardSelectionTransfer {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.session_handle, i);
        arg::RefArg::append(&self.mime_type, i);
        arg::RefArg::append(&self.serial, i);
    }
}

impl arg::ReadAll for OrgFreedesktopPortalClipboardSelectionTransfer {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopPortalClipboardSelectionTransfer {
            session_handle: i.read()?,
            mime_type: i.read()?,
            serial: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopPortalClipboardSelectionTransfer {
    const NAME: &'static str = "SelectionTransfer";
    const INTERFACE: &'static str = "org.freedesktop.portal.Clipboard";
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalClipboard for blocking::Proxy<'a, C> {

    fn request_clipboard(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.Clipboard", "RequestClipboard", (session_handle, options, ))
    }

    fn set_selection(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.Clipboard", "SetSelection", (session_handle, options, ))
    }

    fn selection_write(&self, session_handle: dbus::Path, serial: u32) -> Result<arg::OwnedFd, dbus::Error> {
        self.method_call("org.freedesktop.portal.Clipboard", "SelectionWrite", (session_handle, serial, ))
            .and_then(|r: (arg::OwnedFd, )| Ok(r.0, ))
    }

    fn selection_write_done(&self, session_handle: dbus::Path, serial: u32, success: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.Clipboard", "SelectionWriteDone", (session_handle, serial, success, ))
    }

    fn selection_read(&self, session_handle: dbus::Path, mime_type: &str) -> Result<arg::OwnedFd, dbus::Error> {
        self.method_call("org.freedesktop.portal.Clipboard", "SelectionRead", (session_handle, mime_type, ))
            .and_then(|r: (arg::OwnedFd, )| Ok(r.0, ))
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.Clipboard", "version")
    }
}

pub trait OrgFreedesktopPortalWallpaper {
    fn set_wallpaper_uri(&self, parent_window: &str, uri: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn set_wallpaper_file(&self, parent_window: &str, fd: arg::OwnedFd, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalWallpaper for blocking::Proxy<'a, C> {

    fn set_wallpaper_uri(&self, parent_window: &str, uri: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.Wallpaper", "SetWallpaperURI", (parent_window, uri, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn set_wallpaper_file(&self, parent_window: &str, fd: arg::OwnedFd, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.Wallpaper", "SetWallpaperFile", (parent_window, fd, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.Wallpaper", "version")
    }
}

pub trait OrgFreedesktopPortalCamera {
    fn access_camera(&self, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn open_pipe_wire_remote(&self, options: arg::PropMap) -> Result<arg::OwnedFd, dbus::Error>;
    fn is_camera_present(&self) -> Result<bool, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalCamera for blocking::Proxy<'a, C> {

    fn access_camera(&self, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.Camera", "AccessCamera", (options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn open_pipe_wire_remote(&self, options: arg::PropMap) -> Result<arg::OwnedFd, dbus::Error> {
        self.method_call("org.freedesktop.portal.Camera", "OpenPipeWireRemote", (options, ))
            .and_then(|r: (arg::OwnedFd, )| Ok(r.0, ))
    }

    fn is_camera_present(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.Camera", "IsCameraPresent")
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.Camera", "version")
    }
}

pub trait OrgFreedesktopPortalInputCapture {
    fn create_session(&self, parent_window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn get_zones(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn set_pointer_barriers(&self, session_handle: dbus::Path, options: arg::PropMap, barriers: Vec<arg::PropMap>, zone_set: u32) -> Result<dbus::Path<'static>, dbus::Error>;
    fn enable(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<(), dbus::Error>;
    fn disable(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<(), dbus::Error>;
    fn release(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<(), dbus::Error>;
    fn connect_to_eis(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<arg::OwnedFd, dbus::Error>;
    fn supported_capabilities(&self) -> Result<u32, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

#[derive(Debug)]
pub struct OrgFreedesktopPortalInputCaptureDisabled {
    pub session_handle: dbus::Path<'static>,
    pub options: arg::PropMap,
}

impl arg::AppendAll for OrgFreedesktopPortalInputCaptureDisabled {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.session_handle, i);
        arg::RefArg::append(&self.options, i);
    }
}

impl arg::ReadAll for OrgFreedesktopPortalInputCaptureDisabled {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopPortalInputCaptureDisabled {
            session_handle: i.read()?,
            options: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopPortalInputCaptureDisabled {
    const NAME: &'static str = "Disabled";
    const INTERFACE: &'static str = "org.freedesktop.portal.InputCapture";
}

#[derive(Debug)]
pub struct OrgFreedesktopPortalInputCaptureActivated {
    pub session_handle: dbus::Path<'static>,
    pub options: arg::PropMap,
}

impl arg::AppendAll for OrgFreedesktopPortalInputCaptureActivated {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.session_handle, i);
        arg::RefArg::append(&self.options, i);
    }
}

impl arg::ReadAll for OrgFreedesktopPortalInputCaptureActivated {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopPortalInputCaptureActivated {
            session_handle: i.read()?,
            options: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopPortalInputCaptureActivated {
    const NAME: &'static str = "Activated";
    const INTERFACE: &'static str = "org.freedesktop.portal.InputCapture";
}

#[derive(Debug)]
pub struct OrgFreedesktopPortalInputCaptureDeactivated {
    pub session_handle: dbus::Path<'static>,
    pub options: arg::PropMap,
}

impl arg::AppendAll for OrgFreedesktopPortalInputCaptureDeactivated {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.session_handle, i);
        arg::RefArg::append(&self.options, i);
    }
}

impl arg::ReadAll for OrgFreedesktopPortalInputCaptureDeactivated {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopPortalInputCaptureDeactivated {
            session_handle: i.read()?,
            options: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopPortalInputCaptureDeactivated {
    const NAME: &'static str = "Deactivated";
    const INTERFACE: &'static str = "org.freedesktop.portal.InputCapture";
}

#[derive(Debug)]
pub struct OrgFreedesktopPortalInputCaptureZonesChanged {
    pub session_handle: dbus::Path<'static>,
    pub options: arg::PropMap,
}

impl arg::AppendAll for OrgFreedesktopPortalInputCaptureZonesChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.session_handle, i);
        arg::RefArg::append(&self.options, i);
    }
}

impl arg::ReadAll for OrgFreedesktopPortalInputCaptureZonesChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopPortalInputCaptureZonesChanged {
            session_handle: i.read()?,
            options: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopPortalInputCaptureZonesChanged {
    const NAME: &'static str = "ZonesChanged";
    const INTERFACE: &'static str = "org.freedesktop.portal.InputCapture";
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalInputCapture for blocking::Proxy<'a, C> {

    fn create_session(&self, parent_window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.InputCapture", "CreateSession", (parent_window, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn get_zones(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.InputCapture", "GetZones", (session_handle, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn set_pointer_barriers(&self, session_handle: dbus::Path, options: arg::PropMap, barriers: Vec<arg::PropMap>, zone_set: u32) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.InputCapture", "SetPointerBarriers", (session_handle, options, barriers, zone_set, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn enable(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.InputCapture", "Enable", (session_handle, options, ))
    }

    fn disable(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.InputCapture", "Disable", (session_handle, options, ))
    }

    fn release(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.InputCapture", "Release", (session_handle, options, ))
    }

    fn connect_to_eis(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<arg::OwnedFd, dbus::Error> {
        self.method_call("org.freedesktop.portal.InputCapture", "ConnectToEIS", (session_handle, options, ))
            .and_then(|r: (arg::OwnedFd, )| Ok(r.0, ))
    }

    fn supported_capabilities(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.InputCapture", "SupportedCapabilities")
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.InputCapture", "version")
    }
}

pub trait OrgFreedesktopPortalGlobalShortcuts {
    fn create_session(&self, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn bind_shortcuts(&self, session_handle: dbus::Path, shortcuts: Vec<(&str, arg::PropMap,)>, parent_window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn list_shortcuts(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

#[derive(Debug)]
pub struct OrgFreedesktopPortalGlobalShortcutsActivated {
    pub session_handle: dbus::Path<'static>,
    pub shortcut_id: String,
    pub timestamp: u64,
    pub options: arg::PropMap,
}

impl arg::AppendAll for OrgFreedesktopPortalGlobalShortcutsActivated {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.session_handle, i);
        arg::RefArg::append(&self.shortcut_id, i);
        arg::RefArg::append(&self.timestamp, i);
        arg::RefArg::append(&self.options, i);
    }
}

impl arg::ReadAll for OrgFreedesktopPortalGlobalShortcutsActivated {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopPortalGlobalShortcutsActivated {
            session_handle: i.read()?,
            shortcut_id: i.read()?,
            timestamp: i.read()?,
            options: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopPortalGlobalShortcutsActivated {
    const NAME: &'static str = "Activated";
    const INTERFACE: &'static str = "org.freedesktop.portal.GlobalShortcuts";
}

#[derive(Debug)]
pub struct OrgFreedesktopPortalGlobalShortcutsDeactivated {
    pub session_handle: dbus::Path<'static>,
    pub shortcut_id: String,
    pub timestamp: u64,
    pub options: arg::PropMap,
}

impl arg::AppendAll for OrgFreedesktopPortalGlobalShortcutsDeactivated {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.session_handle, i);
        arg::RefArg::append(&self.shortcut_id, i);
        arg::RefArg::append(&self.timestamp, i);
        arg::RefArg::append(&self.options, i);
    }
}

impl arg::ReadAll for OrgFreedesktopPortalGlobalShortcutsDeactivated {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopPortalGlobalShortcutsDeactivated {
            session_handle: i.read()?,
            shortcut_id: i.read()?,
            timestamp: i.read()?,
            options: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopPortalGlobalShortcutsDeactivated {
    const NAME: &'static str = "Deactivated";
    const INTERFACE: &'static str = "org.freedesktop.portal.GlobalShortcuts";
}

#[derive(Debug)]
pub struct OrgFreedesktopPortalGlobalShortcutsShortcutsChanged {
    pub session_handle: dbus::Path<'static>,
    pub shortcuts: Vec<(String, arg::PropMap,)>,
}

impl arg::AppendAll for OrgFreedesktopPortalGlobalShortcutsShortcutsChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.session_handle, i);
        arg::RefArg::append(&self.shortcuts, i);
    }
}

impl arg::ReadAll for OrgFreedesktopPortalGlobalShortcutsShortcutsChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopPortalGlobalShortcutsShortcutsChanged {
            session_handle: i.read()?,
            shortcuts: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopPortalGlobalShortcutsShortcutsChanged {
    const NAME: &'static str = "ShortcutsChanged";
    const INTERFACE: &'static str = "org.freedesktop.portal.GlobalShortcuts";
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalGlobalShortcuts for blocking::Proxy<'a, C> {

    fn create_session(&self, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.GlobalShortcuts", "CreateSession", (options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn bind_shortcuts(&self, session_handle: dbus::Path, shortcuts: Vec<(&str, arg::PropMap,)>, parent_window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.GlobalShortcuts", "BindShortcuts", (session_handle, shortcuts, parent_window, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn list_shortcuts(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.GlobalShortcuts", "ListShortcuts", (session_handle, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.GlobalShortcuts", "version")
    }
}

pub trait OrgFreedesktopPortalPowerProfileMonitor {
    fn power_saver_enabled(&self) -> Result<bool, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalPowerProfileMonitor for blocking::Proxy<'a, C> {

    fn power_saver_enabled(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.PowerProfileMonitor", "power-saver-enabled")
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.PowerProfileMonitor", "version")
    }
}

pub trait OrgFreedesktopPortalDynamicLauncher {
    fn install(&self, token: &str, desktop_file_id: &str, desktop_entry: &str, options: arg::PropMap) -> Result<(), dbus::Error>;
    fn prepare_install(&self, parent_window: &str, name: &str, icon_v: arg::Variant<Box<dyn arg::RefArg>>, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn request_install_token(&self, name: &str, icon_v: arg::Variant<Box<dyn arg::RefArg>>, options: arg::PropMap) -> Result<String, dbus::Error>;
    fn uninstall(&self, desktop_file_id: &str, options: arg::PropMap) -> Result<(), dbus::Error>;
    fn get_desktop_entry(&self, desktop_file_id: &str) -> Result<String, dbus::Error>;
    fn get_icon(&self, desktop_file_id: &str) -> Result<(arg::Variant<Box<dyn arg::RefArg + 'static>>, String, u32), dbus::Error>;
    fn launch(&self, desktop_file_id: &str, options: arg::PropMap) -> Result<(), dbus::Error>;
    fn supported_launcher_types(&self) -> Result<u32, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalDynamicLauncher for blocking::Proxy<'a, C> {

    fn install(&self, token: &str, desktop_file_id: &str, desktop_entry: &str, options: arg::PropMap) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.DynamicLauncher", "Install", (token, desktop_file_id, desktop_entry, options, ))
    }

    fn prepare_install(&self, parent_window: &str, name: &str, icon_v: arg::Variant<Box<dyn arg::RefArg>>, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.DynamicLauncher", "PrepareInstall", (parent_window, name, icon_v, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn request_install_token(&self, name: &str, icon_v: arg::Variant<Box<dyn arg::RefArg>>, options: arg::PropMap) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.portal.DynamicLauncher", "RequestInstallToken", (name, icon_v, options, ))
            .and_then(|r: (String, )| Ok(r.0, ))
    }

    fn uninstall(&self, desktop_file_id: &str, options: arg::PropMap) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.DynamicLauncher", "Uninstall", (desktop_file_id, options, ))
    }

    fn get_desktop_entry(&self, desktop_file_id: &str) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.portal.DynamicLauncher", "GetDesktopEntry", (desktop_file_id, ))
            .and_then(|r: (String, )| Ok(r.0, ))
    }

    fn get_icon(&self, desktop_file_id: &str) -> Result<(arg::Variant<Box<dyn arg::RefArg + 'static>>, String, u32), dbus::Error> {
        self.method_call("org.freedesktop.portal.DynamicLauncher", "GetIcon", (desktop_file_id, ))
    }

    fn launch(&self, desktop_file_id: &str, options: arg::PropMap) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.portal.DynamicLauncher", "Launch", (desktop_file_id, options, ))
    }

    fn supported_launcher_types(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.DynamicLauncher", "SupportedLauncherTypes")
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.DynamicLauncher", "version")
    }
}

pub trait OrgFreedesktopPortalScreenCast {
    fn create_session(&self, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn select_sources(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn start(&self, session_handle: dbus::Path, parent_window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn open_pipe_wire_remote(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<arg::OwnedFd, dbus::Error>;
    fn available_source_types(&self) -> Result<u32, dbus::Error>;
    fn available_cursor_modes(&self) -> Result<u32, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalScreenCast for blocking::Proxy<'a, C> {

    fn create_session(&self, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.ScreenCast", "CreateSession", (options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn select_sources(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.ScreenCast", "SelectSources", (session_handle, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn start(&self, session_handle: dbus::Path, parent_window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.ScreenCast", "Start", (session_handle, parent_window, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn open_pipe_wire_remote(&self, session_handle: dbus::Path, options: arg::PropMap) -> Result<arg::OwnedFd, dbus::Error> {
        self.method_call("org.freedesktop.portal.ScreenCast", "OpenPipeWireRemote", (session_handle, options, ))
            .and_then(|r: (arg::OwnedFd, )| Ok(r.0, ))
    }

    fn available_source_types(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.ScreenCast", "AvailableSourceTypes")
    }

    fn available_cursor_modes(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.ScreenCast", "AvailableCursorModes")
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.ScreenCast", "version")
    }
}

pub trait OrgFreedesktopHostPortalRegistry {
    fn register(&self, app_id: &str, options: arg::PropMap) -> Result<(), dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopHostPortalRegistry for blocking::Proxy<'a, C> {

    fn register(&self, app_id: &str, options: arg::PropMap) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.host.portal.Registry", "Register", (app_id, options, ))
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.host.portal.Registry", "version")
    }
}

pub trait OrgFreedesktopPortalEmail {
    fn compose_email(&self, parent_window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalEmail for blocking::Proxy<'a, C> {

    fn compose_email(&self, parent_window: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.Email", "ComposeEmail", (parent_window, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.Email", "version")
    }
}

pub trait OrgFreedesktopPortalTrash {
    fn trash_file(&self, fd: arg::OwnedFd) -> Result<u32, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalTrash for blocking::Proxy<'a, C> {

    fn trash_file(&self, fd: arg::OwnedFd) -> Result<u32, dbus::Error> {
        self.method_call("org.freedesktop.portal.Trash", "TrashFile", (fd, ))
            .and_then(|r: (u32, )| Ok(r.0, ))
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.Trash", "version")
    }
}

pub trait OrgFreedesktopPortalProxyResolver {
    fn lookup(&self, uri: &str) -> Result<Vec<String>, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalProxyResolver for blocking::Proxy<'a, C> {

    fn lookup(&self, uri: &str) -> Result<Vec<String>, dbus::Error> {
        self.method_call("org.freedesktop.portal.ProxyResolver", "Lookup", (uri, ))
            .and_then(|r: (Vec<String>, )| Ok(r.0, ))
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.ProxyResolver", "version")
    }
}

pub trait OrgFreedesktopPortalFileChooser {
    fn open_file(&self, parent_window: &str, title: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn save_file(&self, parent_window: &str, title: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn save_files(&self, parent_window: &str, title: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error>;
    fn version(&self) -> Result<u32, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> OrgFreedesktopPortalFileChooser for blocking::Proxy<'a, C> {

    fn open_file(&self, parent_window: &str, title: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.FileChooser", "OpenFile", (parent_window, title, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn save_file(&self, parent_window: &str, title: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.FileChooser", "SaveFile", (parent_window, title, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn save_files(&self, parent_window: &str, title: &str, options: arg::PropMap) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.portal.FileChooser", "SaveFiles", (parent_window, title, options, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn version(&self) -> Result<u32, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(self, "org.freedesktop.portal.FileChooser", "version")
    }
}
